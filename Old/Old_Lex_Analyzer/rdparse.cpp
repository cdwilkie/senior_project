/* C. DUSTIN WILKIE
 * COMP 360 001
 * PROJECT 01
 * LEXICAL ANALYZER
*/


/* rdparse.cpp - Recursive-Descent Parser for
 * Sample Programming Language.  Parser subprograms
 * that support BNF grammar for Sample Programming
 * Language.  Subprogram support for <PROGRAM>, <KEYWORD>,
 * <IDENT>, <DECALRES>, <STMTS>, <ASSIGN>, and <EXPR>
 */

#include "front.h"
#include "rdparse.h"

int errorCount = 0;
//----------------------------------------//
/* program - Parses strings in the language 
 * generated by the rule:
 * <program> -> <keyword> <ident> () { <declares> <stmts>}
 */
void program() {
    std::cout << "Entering <program>\n";

    keyword();                                  //<KEYWORD> Parse
    
    ident();                                    //<IDENT> Parse

    //Left Parenthesis expected
    if (nextToken != LEFT_PAREN) {              //If nexToken not "("
        std::cout << "Syntax Error - LEFT_PAREN expected\n";
        errorCount++;
    }//end if not parenthesis
    lex();                                      //Generate next token type

    //Right Parenthesis expected
    if (nextToken != RIGHT_PAREN) {             //If nextToken != ")"
        std::cout << "Syntax Error - RIGHT_PAREN expected\n";
        errorCount++;
    }//end if nextToken not parenthesis
    lex();                                      //Generate next token type

    //Left Brace expected
    if (nextToken != LEFT_BRACE) {              //If nextToken not "{"
        std::cout << "Syntax Error - LEFT_BRACE expected\n";
        errorCount++;
    }//end if nextToken not left brace
    lex();                                      //Generate next token type

    
    declares();                                 //<Declares> Parse

    
    stmts();                                    //<Statements> Parse

    //Right Brace expected
    if (nextToken != RIGHT_BRACE) {             //If nextToken not equal "}"
        std::cout << "Syntax Error - Expecting RIGHT_BRACE\n";
        errorCount++;
    }//end if nextToken not right brace
    lex();                                      //Generate next token type(EOF)
    std::cout << "Exiting <program>\n";
}//end program()
/******************************************/

/* keyword - Parses strings in the lanaguage 
 * generated by the rule:
 * <keyword> -> float
 */
void keyword() {
    printf("Entering <keyword>\n");
    if (strcmp(lexeme,"float") != 0) {          //If lexeme value != "float"
        std::cout << "Syntax Error - KEYWORD != 'float'\n";
        errorCount++;
    }
    lex();                                      //Generate next token type
    std::cout << "Exiting <keyword>\n";
}//end keyword()
/******************************************/

/* ident - Parses strings in the language 
 * generated by the rule:
 * <ident> -> a <ident>| b <ident>...| z <ident> |
*/
void ident() {
    std::cout<<"Entering <ident>\n";
     
    if (nextToken != IDENT) {                   //If next token not IDENT type
        std::cout << "Syntax Error - IDENT expected\n";
        errorCount++;
    }//end if not IDENT
    else {                                      //Else token is IDENT type
        for (int i = 0; i < strlen(lexeme); ++i) {//Check for upper letters
            if ((isupper(lexeme[i]) != 0))  {   //If upper letter found
                std::cout << "Syntax Error - expecting lowercase letters<<\n";
                errorCount++;
                break;
            }//end if upper letter found
        }//end for check upper letters
    }//end
    lex();                                      //Generate next token type
    std::cout<<"Exiting <ident>\n";
}//end ident()
/******************************************/

/* declares - Parses strings in the language 
 * genearted by the rule:
 * <declares> -> <keyword> <ident>;
 *             | <keyword> <ident>; <declares>
*/
void declares() {
    std::cout << "Entering <declares>\n";
    keyword();                                  //<KEYWORD> Parse

    ident();                                    //<IDENT> Parse

    if (nextToken != SEMI_COLON) {              //If next token is not ";"
        std::cout << "Syntax Error - SEMI_COLON expected\n";
        errorCount++;
    }//end if not ";"
    lex();                                      //Generate next token type
    while (nextToken == KEYWORD) {              //While next token is KEYWORD
        declares();                             //<DECLARES> Parse
    }//end while nextToken is keyword
    
    std::cout << "Exiting <declares>\n";
}//end delcares()
/******************************************/

/* stmts - Parses strings in the language 
 * generated by the rule:
 * <stmts> -> <assign>; <stms>
 *          | <assign>;
*/
void stmts() {
    std::cout << ("Entering <stmts>\n");
    
    assign();                                   //<ASSIGN> Parse
    if (nextToken != SEMI_COLON) {              //If next token is not ";"
        std::cout <<"Syntax Error - Expected SEMI_COLON\n";
        errorCount++;
    }//end if nextToken is not ";"
    lex();                                      //Generate next token type
    if (nextToken == IDENT) {                   //If next token is IDENT
        stmts();                                //<STMTS> Parse
    }//end if next token is IDENT
    
    std::cout<< "Exiting <stmts>\n";
}//end stmts()
/******************************************/

/* assign - Parses strings in the language generated by
 * the rule: 
 * <assign> -> <ident> = <expr>
*/
void assign() {
    std::cout << "Entering <assign>\n";
    
    ident();                                    //<IDENT> Parse
    if (nextToken != ASSIGN_OP) {               //If next token is not "="
        std::cout << "Syntax Error - Expected ASSIGN_OP\n";
        errorCount++;
    }//end if nextToken not =
    lex();                                      //Generate next token type
    expr();                                     //<EXPR> Parse
    std::cout << "Exiting <assign>\n";
    
}//end assign()
/******************************************/

/* expr - Parses the strings in the language generated by
 * the rule:
 * <expr> -> <ident> {*|/} <expr>
 *         | <ident>
*/
void expr() {
    std::cout << "Entering <expr>\n";
    
    ident();                                    //<IDENT> Parse
    while (nextToken == MULT_OP || nextToken == DIV_OP) {//While valid symbol
        lex();                                  //Generate next token type
        expr();                                 //<EXPR> Parse
    }//end while valid symbol * or /
    if (nextToken == SEMI_COLON) {              //If next token is ";"
        std::cout << "Exiting <expr>\n";
    }//end if nextToken ";"
    else {                                      //Else invalid symbol 
        std::cout << "Syntax Error - MULT_OP, DIV_OP, or SEMI_COLON expected\n";
        errorCount++;
        std::cout << "Exiting <expr>\n";
    }//end else invalid symbol
}//end expr()

